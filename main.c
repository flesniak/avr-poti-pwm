#define F_CPU 9600000

#include <avr/interrupt.h>
#include <avr/io.h>
#include <avr/sleep.h>
#include <util/delay.h>
#include <stdbool.h>

// generated by generate-lut.py
#include "table.h"

#define CUR_PER_POT_MEASURES 255 // 8-bit value, each n current measurements 1 potentiometer measurement is done
#define ADMUX_CUR ((1 << REFS0) | (1 << MUX1) | (0 << MUX0)) // REFS0=1 internal reference 1.1V, PB4/ADC2
#define ADMUX_POT ((0 << REFS0) | (1 << MUX1) | (1 << MUX0)) // REFS0=0 Vcc reference 5V, PB3/ADC3
#define WAIT_ADC_READY do {} while(ADCSRA & (1 << ADSC))

ISR(TIM0_OVF_vect) {
  ADCSRA |= (1 << ADEN); // trigger conversion at BOTTOM=T_on/2 -> gets approx. mean current
}

bool direct_pwm = false;
uint16_t sense_target = SENSE_TARGET;

void update_pwm(uint16_t adc) {
  if (direct_pwm)
    OCR0A = sense_target;
  else {
    if (adc < sense_target && OCR0A < 0xff)
      OCR0A++;
    else if (adc > sense_target && OCR0A > 0)
      OCR0A--;
  }
}

void update_pot(uint16_t adc) {
  direct_pwm = ((adc >> 4) < DIRECT_PWM_LIMIT);
  sense_target = pgm_read_byte(&(brightness_lut[adc>>4]));
}

int main() {
  DDRB = 0b00000001; // 5=reset, 4=current sense, 3=pot, 21=NC, 0=pwm out
  PORTB = 0b00000110;

  TCNT0 = 0;
  OCR0A = 0; // start at mosfet off
  TCCR0A = (1 << COM0A1) | (0 << COM0A0) | (0 << WGM01) | (1 << WGM00); // phase correct pwm mode, clear OC0A on compare match when up-counting, set when down-counting
  TCCR0B = (0 << CS02) | (0 << CS01) | (1 << CS00); // no prescaler -> 9.6MHz/256 = 37.5kHz PWM clock
  TIMSK0 = (1 << TOIE0); // overflow interrupt - triggered on MAX for phase correct pwm mode

  ADMUX = ADMUX_CUR; // start with current measure
  ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (0 << ADPS0);
  while(ADCSRA & (1 << ADSC)); // wait for adc init

  sei();

  unsigned char convcount = 0;

  while(1) {
    sleep_mode(); // sleep until conversion is triggered
    WAIT_ADC_READY;
    if (convcount != CUR_PER_POT_MEASURES) {
      update_pwm(ADC);
      convcount++;
      if (convcount == CUR_PER_POT_MEASURES)
        ADMUX = ADMUX_POT; // switch to potentiometer measure
    } else {
      ADCSRA |= (1 << ADEN); // first measure after reference switch is inaccurate, drop it
      WAIT_ADC_READY;
      update_pot(ADC);
      ADMUX = ADMUX_CUR;
      ADCSRA |= (1 << ADEN);
      WAIT_ADC_READY; // first measure after reference switch is inaccurate, drop it
      convcount = 0;
    }
  }

  return 0;
}
